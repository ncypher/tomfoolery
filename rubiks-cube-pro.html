<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Rubik's Cube Pro - Enhanced</title>
  <style>
    :root {
      --bg: #0b0e14;
      --panel: #0f1420;
      --border: #1a2233;
      --text: #eaeef5;
      --muted: #9fb0c7;
      --accent: #2251f6;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto;
      overflow: hidden;
    }
    
    #container {
      display: grid;
      grid-template-columns: 320px 1fr;
      height: 100vh;
    }
    
    #controls {
      background: var(--panel);
      border-right: 1px solid var(--border);
      padding: 20px;
      overflow-y: auto;
    }
    
    .control-section {
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(26, 34, 51, 0.3);
      border: 1px solid var(--border);
      border-radius: 8px;
    }
    
    .control-section h3 {
      margin-bottom: 10px;
      color: var(--accent);
    }
    
    .button-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    
    button {
      padding: 8px 12px;
      background: #1a2233;
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    button:hover {
      background: var(--accent);
    }
    
    .primary {
      background: var(--accent);
    }
    
    #gameArea {
      position: relative;
      background: radial-gradient(circle at center, #1a2233 0%, var(--bg) 70%);
    }
    
    #instructions {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(15, 20, 32, 0.9);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 12px;
      line-height: 1.4;
      max-width: 200px;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="controls">
      <h2 style="margin-bottom: 20px; color: var(--accent);">üöÄ Rubik's Cube Pro</h2>
      
      <div class="control-section">
        <h3>üéÆ Game Controls</h3>
        <div class="button-row">
          <button id="scramble" class="primary">üîÄ Scramble</button>
          <button id="solve">‚úÖ Solve</button>
          <button id="reset">‚ôªÔ∏è Reset</button>
        </div>
        <div style="font-size: 12px; color: var(--muted);">
          Moves: <span id="moveCount">0</span> | 
          Status: <span id="status">Ready</span>
        </div>
      </div>
      
      <div class="control-section">
        <h3>üîÑ Face Rotations</h3>
        <div class="button-row">
          <button onclick="rotateFace('U')">U</button>
          <button onclick="rotateFace('U', true)">U'</button>
          <button onclick="rotateFace('U', false, true)">U2</button>
        </div>
        <div class="button-row">
          <button onclick="rotateFace('D')">D</button>
          <button onclick="rotateFace('D', true)">D'</button>
          <button onclick="rotateFace('D', false, true)">D2</button>
        </div>
        <div class="button-row">
          <button onclick="rotateFace('R')">R</button>
          <button onclick="rotateFace('R', true)">R'</button>
          <button onclick="rotateFace('R', false, true)">R2</button>
        </div>
        <div class="button-row">
          <button onclick="rotateFace('L')">L</button>
          <button onclick="rotateFace('L', true)">L'</button>
          <button onclick="rotateFace('L', false, true)">L2</button>
        </div>
        <div class="button-row">
          <button onclick="rotateFace('F')">F</button>
          <button onclick="rotateFace('F', true)">F'</button>
          <button onclick="rotateFace('F', false, true)">F2</button>
        </div>
        <div class="button-row">
          <button onclick="rotateFace('B')">B</button>
          <button onclick="rotateFace('B', true)">B'</button>
          <button onclick="rotateFace('B', false, true)">B2</button>
        </div>
      </div>
      
      <div class="control-section">
        <h3>üìä Statistics</h3>
        <div style="font-size: 12px; line-height: 1.6;">
          <div>Total Moves: <span id="totalMoves">0</span></div>
          <div>Session Time: <span id="timer">00:00</span></div>
          <div>Cube State: <span id="cubeState">Solved</span></div>
        </div>
      </div>
    </div>
    
    <div id="gameArea">
      <div id="instructions">
        <strong>Controls:</strong><br>
        ‚Ä¢ Drag to rotate view<br>
        ‚Ä¢ Scroll to zoom<br>
        ‚Ä¢ Click cube faces to rotate<br>
        ‚Ä¢ Keys: U,D,L,R,F,B<br>
        ‚Ä¢ Hold Shift for prime moves<br>
        ‚Ä¢ Press 2 for double moves
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    class RubiksCube {
      constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.cubes = [];
        this.cubeStates = []; // Track cube states separately
        this.isAnimating = false;
        this.animationQueue = [];
        this.moveHistory = [];
        this.totalMoves = 0;
        this.startTime = Date.now();
        
        this.init();
        this.createCube();
        this.setupControls();
        this.setupEventListeners();
        this.animate();
        this.updateTimer();
      }
      
      init() {
        const gameArea = document.getElementById('gameArea');
        this.renderer.setSize(gameArea.clientWidth, gameArea.clientHeight);
        this.renderer.setClearColor(0x0b0e14);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        gameArea.appendChild(this.renderer.domElement);
        
        // Camera position
        this.camera.position.set(8, 8, 8);
        this.camera.lookAt(0, 0, 0);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        this.scene.add(directionalLight);
        
        const pointLight = new THREE.PointLight(0x2251f6, 0.3);
        pointLight.position.set(-5, 5, 5);
        this.scene.add(pointLight);
      }
      
      createCube() {
        const colors = {
          front: 0x00ff00,   // Green
          back: 0x0000ff,    // Blue  
          right: 0xff0000,   // Red
          left: 0xff8c00,    // Orange
          top: 0xffffff,     // White
          bottom: 0xffff00   // Yellow
        };
        
        const cubeSize = 0.95;
        const gap = 0.05;
        
        // Create cube state tracking
        this.cubeStates = [];
        
        // Create 27 individual cubes (3x3x3)
        let index = 0;
        for (let x = -1; x <= 1; x++) {
          for (let y = -1; y <= 1; y++) {
            for (let z = -1; z <= 1; z++) {
              const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
              
              // Create materials for each face
              const materials = [
                new THREE.MeshLambertMaterial({ color: x === 1 ? colors.right : 0x222222 }),  // Right
                new THREE.MeshLambertMaterial({ color: x === -1 ? colors.left : 0x222222 }),  // Left
                new THREE.MeshLambertMaterial({ color: y === 1 ? colors.top : 0x222222 }),    // Top
                new THREE.MeshLambertMaterial({ color: y === -1 ? colors.bottom : 0x222222 }), // Bottom
                new THREE.MeshLambertMaterial({ color: z === 1 ? colors.front : 0x222222 }),  // Front
                new THREE.MeshLambertMaterial({ color: z === -1 ? colors.back : 0x222222 })   // Back
              ];
              
              const cube = new THREE.Mesh(geometry, materials);
              const position = new THREE.Vector3(
                x * (cubeSize + gap), 
                y * (cubeSize + gap), 
                z * (cubeSize + gap)
              );
              
              cube.position.copy(position);
              cube.castShadow = true;
              cube.receiveShadow = true;
              
              // Store cube state separately for safety
              this.cubeStates[index] = {
                index: index,
                gridX: x,
                gridY: y,
                gridZ: z,
                position: position.clone(),
                rotation: new THREE.Euler(0, 0, 0),
                visible: true
              };
              
              cube.userData = { index: index };
              
              this.scene.add(cube);
              this.cubes[index] = cube;
              index++;
            }
          }
        }
        
        console.log(`Created ${this.cubes.length} cubes`);
      }
      
      setupControls() {
        this.mouse = { x: 0, y: 0 };
        this.isMouseDown = false;
        this.rotationX = 0;
        this.rotationY = 0;
        
        const canvas = this.renderer.domElement;
        
        canvas.addEventListener('mousedown', (e) => {
          this.isMouseDown = true;
          this.mouse.x = e.clientX;
          this.mouse.y = e.clientY;
        });
        
        canvas.addEventListener('mousemove', (e) => {
          if (!this.isMouseDown || this.isAnimating) return;
          
          const deltaX = e.clientX - this.mouse.x;
          const deltaY = e.clientY - this.mouse.y;
          
          this.rotationY += deltaX * 0.01;
          this.rotationX += deltaY * 0.01;
          
          // Limit rotation
          this.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotationX));
          
          this.updateCameraPosition();
          
          this.mouse.x = e.clientX;
          this.mouse.y = e.clientY;
        });
        
        canvas.addEventListener('mouseup', () => {
          this.isMouseDown = false;
        });
        
        canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          const distance = this.camera.position.length();
          const newDistance = Math.max(5, Math.min(15, distance + e.deltaY * 0.01));
          this.camera.position.setLength(newDistance);
        });
      }
      
      updateCameraPosition() {
        const distance = this.camera.position.length();
        this.camera.position.x = distance * Math.sin(this.rotationY) * Math.cos(this.rotationX);
        this.camera.position.y = distance * Math.sin(this.rotationX);
        this.camera.position.z = distance * Math.cos(this.rotationY) * Math.cos(this.rotationX);
        this.camera.lookAt(0, 0, 0);
      }
      
      rotateFace(face, isPrime = false, isDouble = false) {
        // Add to animation queue instead of executing immediately
        const move = { face, isPrime, isDouble };
        this.animationQueue.push(move);
        
        if (!this.isAnimating) {
          this.processQueue();
        }
      }
      
      processQueue() {
        if (this.animationQueue.length === 0) {
          this.isAnimating = false;
          return;
        }
        
        this.isAnimating = true;
        const move = this.animationQueue.shift();
        this.executeSingleMove(move.face, move.isPrime, move.isDouble);
      }
      
      executeSingleMove(face, isPrime = false, isDouble = false) {
        console.log(`Executing move: ${face}${isPrime ? "'" : ''}${isDouble ? '2' : ''}`);
        
        const rotationAngle = isPrime ? Math.PI/2 : -Math.PI/2;
        const iterations = isDouble ? 2 : 1;
        
        // Get cube indices that belong to this face
        const faceIndices = this.getFaceIndices(face);
        console.log(`Face ${face} has ${faceIndices.length} cubes`);
        
        this.animateRotation(faceIndices, face, rotationAngle, iterations, () => {
          this.recordMove(face, isPrime, isDouble);
          this.updateUI();
          this.processQueue(); // Process next move in queue
        });
      }
      
      getFaceIndices(face) {
        const indices = [];
        for (let i = 0; i < this.cubeStates.length; i++) {
          const state = this.cubeStates[i];
          if (!state.visible) continue;
          
          let belongsToFace = false;
          switch (face) {
            case 'U': belongsToFace = (state.gridY === 1); break;
            case 'D': belongsToFace = (state.gridY === -1); break;
            case 'R': belongsToFace = (state.gridX === 1); break;
            case 'L': belongsToFace = (state.gridX === -1); break;
            case 'F': belongsToFace = (state.gridZ === 1); break;
            case 'B': belongsToFace = (state.gridZ === -1); break;
          }
          
          if (belongsToFace) {
            indices.push(i);
          }
        }
        return indices;
      }
      
      animateRotation(cubeIndices, face, angle, iterations, callback) {
        let currentIteration = 0;
        
        const performRotation = () => {
          console.log(`Performing rotation ${currentIteration + 1}/${iterations} for face ${face}`);
          
          // Store initial positions and rotations
          const initialStates = cubeIndices.map(index => ({
            index,
            position: this.cubes[index].position.clone(),
            rotation: this.cubes[index].rotation.clone()
          }));
          
          let progress = 0;
          const duration = 250; // ms
          const startTime = Date.now();
          
          const animate = () => {
            const elapsed = Date.now() - startTime;
            progress = Math.min(elapsed / duration, 1);
            
            // Smooth easing function
            const eased = 1 - Math.pow(1 - progress, 3);
            
            // Apply rotation to each cube individually
            cubeIndices.forEach((index, i) => {
              if (!this.cubes[index] || !this.cubeStates[index]) return;
              
              const cube = this.cubes[index];
              const initial = initialStates[i];
              
              // Calculate rotation around face center
              const rotationMatrix = this.getRotationMatrix(face, angle * eased);
              const newPosition = initial.position.clone().applyMatrix4(rotationMatrix);
              const newRotation = initial.rotation.clone();
              
              // Apply rotation to the cube's own rotation
              switch (face) {
                case 'U': case 'D':
                  newRotation.y += angle * eased;
                  break;
                case 'R': case 'L':
                  newRotation.x += angle * eased;
                  break;
                case 'F': case 'B':
                  newRotation.z += angle * eased;
                  break;
              }
              
              cube.position.copy(newPosition);
              cube.rotation.copy(newRotation);
            });
            
            if (progress < 1) {
              requestAnimationFrame(animate);
            } else {
              // Animation complete - update cube states
              this.updateCubeStatesAfterRotation(cubeIndices, face, angle > 0);
              
              currentIteration++;
              if (currentIteration < iterations) {
                setTimeout(performRotation, 50);
              } else {
                callback();
              }
            }
          };
          
          animate();
        };
        
        performRotation();
      }
      
      getRotationMatrix(face, angle) {
        const matrix = new THREE.Matrix4();
        switch (face) {
          case 'U':
            matrix.makeRotationY(angle);
            break;
          case 'D':
            matrix.makeRotationY(-angle);
            break;
          case 'R':
            matrix.makeRotationX(angle);
            break;
          case 'L':
            matrix.makeRotationX(-angle);
            break;
          case 'F':
            matrix.makeRotationZ(angle);
            break;
          case 'B':
            matrix.makeRotationZ(-angle);
            break;
        }
        return matrix;
      }
      
      updateCubeStatesAfterRotation(cubeIndices, face, clockwise) {
        cubeIndices.forEach(index => {
          const state = this.cubeStates[index];
          if (!state) return;
          
          const { gridX, gridY, gridZ } = state;
          let newX = gridX, newY = gridY, newZ = gridZ;
          
          switch (face) {
            case 'U':
              if (clockwise) {
                newX = -gridZ;
                newZ = gridX;
              } else {
                newX = gridZ;
                newZ = -gridX;
              }
              break;
            case 'D':
              if (clockwise) {
                newX = gridZ;
                newZ = -gridX;
              } else {
                newX = -gridZ;
                newZ = gridX;
              }
              break;
            case 'R':
              if (clockwise) {
                newY = -gridZ;
                newZ = gridY;
              } else {
                newY = gridZ;
                newZ = -gridY;
              }
              break;
            case 'L':
              if (clockwise) {
                newY = gridZ;
                newZ = -gridY;
              } else {
                newY = -gridZ;
                newZ = gridY;
              }
              break;
            case 'F':
              if (clockwise) {
                newX = gridY;
                newY = -gridX;
              } else {
                newX = -gridY;
                newY = gridX;
              }
              break;
            case 'B':
              if (clockwise) {
                newX = -gridY;
                newY = gridX;
              } else {
                newX = gridY;
                newY = -gridX;
              }
              break;
          }
          
          // Update cube state
          state.gridX = newX;
          state.gridY = newY;
          state.gridZ = newZ;
          
          // Update cube position
          const cubeSize = 0.95;
          const gap = 0.05;
          const newPosition = new THREE.Vector3(
            newX * (cubeSize + gap),
            newY * (cubeSize + gap),
            newZ * (cubeSize + gap)
          );
          
          state.position.copy(newPosition);
          if (this.cubes[index]) {
            this.cubes[index].position.copy(newPosition);
          }
        });
        
        console.log(`Updated positions for ${cubeIndices.length} cubes after ${face} rotation`);
      }
      
      recordMove(face, isPrime, isDouble) {
        let move = face;
        if (isDouble) move += '2';
        else if (isPrime) move += "'";
        
        this.moveHistory.push(move);
        this.totalMoves++;
      }
      
      scramble() {
        if (this.isAnimating) return;
        
        const moves = ['U', 'D', 'L', 'R', 'F', 'B'];
        const modifiers = ['', "'", '2'];
        
        let scrambleSequence = [];
        for (let i = 0; i < 20; i++) {
          const move = moves[Math.floor(Math.random() * moves.length)];
          const modifier = modifiers[Math.floor(Math.random() * modifiers.length)];
          scrambleSequence.push(move + modifier);
        }
        
        this.executeSequence(scrambleSequence);
      }
      
      executeSequence(sequence) {
        if (sequence.length === 0) return;
        
        const move = sequence.shift();
        const face = move[0];
        const isPrime = move.includes("'");
        const isDouble = move.includes('2');
        
        this.rotateFace(face, isPrime, isDouble);
        
        setTimeout(() => {
          this.executeSequence(sequence);
        }, 400);
      }
      
      solve() {
        if (this.isAnimating) return;
        
        const reverseSequence = this.moveHistory.slice().reverse().map(move => {
          if (move.includes('2')) return move;
          if (move.includes("'")) return move[0];
          return move[0] + "'";
        });
        
        this.moveHistory = [];
        this.executeSequence(reverseSequence);
      }
      
      reset() {
        if (this.isAnimating) {
          this.animationQueue = []; // Clear queue
        }
        this.isAnimating = false;
        
        this.moveHistory = [];
        this.totalMoves = 0;
        
        // Reset all cube positions and orientations
        for (let i = 0; i < this.cubes.length; i++) {
          const cube = this.cubes[i];
          const state = this.cubeStates[i];
          
          if (cube && state) {
            // Reset to original grid position
            const x = Math.floor(i / 9) - 1;
            const y = Math.floor((i % 9) / 3) - 1;
            const z = (i % 3) - 1;
            
            state.gridX = x;
            state.gridY = y;
            state.gridZ = z;
            state.visible = true;
            
            const cubeSize = 0.95;
            const gap = 0.05;
            const position = new THREE.Vector3(
              x * (cubeSize + gap), 
              y * (cubeSize + gap), 
              z * (cubeSize + gap)
            );
            
            state.position.copy(position);
            cube.position.copy(position);
            cube.rotation.set(0, 0, 0);
            state.rotation.set(0, 0, 0);
            
            // Ensure cube is visible and in scene
            cube.visible = true;
            if (!this.scene.children.includes(cube)) {
              this.scene.add(cube);
            }
          }
        }
        
        console.log('Cube reset completed');
        this.updateUI();
      }
      
      updateUI() {
        document.getElementById('moveCount').textContent = this.moveHistory.length;
        document.getElementById('totalMoves').textContent = this.totalMoves;
        document.getElementById('cubeState').textContent = this.moveHistory.length === 0 ? 'Solved' : 'Scrambled';
        document.getElementById('status').textContent = this.isAnimating ? 'Animating...' : 'Ready';
      }
      
      updateTimer() {
        const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        document.getElementById('timer').textContent = `${minutes}:${seconds}`;
        
        setTimeout(() => this.updateTimer(), 1000);
      }
      
      setupEventListeners() {
        document.getElementById('scramble').addEventListener('click', () => this.scramble());
        document.getElementById('solve').addEventListener('click', () => this.solve());
        document.getElementById('reset').addEventListener('click', () => this.reset());
        
        document.addEventListener('keydown', (e) => {
          if (this.isAnimating) return;
          
          const key = e.key.toLowerCase();
          const isPrime = e.shiftKey;
          const isDouble = e.key === '2';
          
          switch (key) {
            case 'u': this.rotateFace('U', isPrime, isDouble); break;
            case 'd': this.rotateFace('D', isPrime, isDouble); break;
            case 'l': this.rotateFace('L', isPrime, isDouble); break;
            case 'r': this.rotateFace('R', isPrime, isDouble); break;
            case 'f': this.rotateFace('F', isPrime, isDouble); break;
            case 'b': this.rotateFace('B', isPrime, isDouble); break;
          }
        });
        
        window.addEventListener('resize', () => {
          const gameArea = document.getElementById('gameArea');
          this.camera.aspect = gameArea.clientWidth / gameArea.clientHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(gameArea.clientWidth, gameArea.clientHeight);
        });
      }
      
      animate() {
        requestAnimationFrame(() => this.animate());
        this.renderer.render(this.scene, this.camera);
      }
    }
    
    // Global function for button clicks
    let cubeInstance;
    
    function rotateFace(face, isPrime = false, isDouble = false) {
      if (cubeInstance) {
        cubeInstance.rotateFace(face, isPrime, isDouble);
      }
    }
    
    // Initialize when page loads
    window.addEventListener('load', () => {
      cubeInstance = new RubiksCube();
    });
  </script>
</body>
</html>