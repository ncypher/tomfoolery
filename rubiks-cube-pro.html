<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Rubik's Cube Pro - Enhanced</title>
  <style>
    :root {
      --bg: #0b0e14;
      --panel: #0f1420;
      --border: #1a2233;
      --text: #eaeef5;
      --muted: #9fb0c7;
      --accent: #2251f6;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: var(--bg);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto;
      overflow: hidden;
    }
    
    #container {
      display: grid;
      grid-template-columns: 320px 1fr;
      height: 100vh;
    }
    
    #controls {
      background: var(--panel);
      border-right: 1px solid var(--border);
      padding: 20px;
      overflow-y: auto;
    }
    
    .control-section {
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(26, 34, 51, 0.3);
      border: 1px solid var(--border);
      border-radius: 8px;
    }
    
    .control-section h3 {
      margin-bottom: 10px;
      color: var(--accent);
    }
    
    .button-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    
    button {
      padding: 8px 12px;
      background: #1a2233;
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    button:hover {
      background: var(--accent);
    }
    
    .primary {
      background: var(--accent);
    }
    
    #gameArea {
      position: relative;
      background: radial-gradient(circle at center, #1a2233 0%, var(--bg) 70%);
    }
    
    #instructions {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(15, 20, 32, 0.9);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid var(--border);
      font-size: 12px;
      line-height: 1.4;
      max-width: 200px;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="controls">
      <h2 style="margin-bottom: 20px; color: var(--accent);">üöÄ Rubik's Cube Pro</h2>
      
      <div class="control-section">
        <h3>üéÆ Game Controls</h3>
        <div class="button-row">
          <button id="scramble" class="primary">üîÄ Scramble</button>
          <button id="solve">‚úÖ Solve</button>
          <button id="reset">‚ôªÔ∏è Reset</button>
        </div>
        <div style="font-size: 12px; color: var(--muted);">
          Moves: <span id="moveCount">0</span> | 
          Status: <span id="status">Ready</span>
        </div>
      </div>
      
      <div class="control-section">
        <h3>üîÑ Face Rotations</h3>
        <div class="button-row">
          <button onclick="rotateFace('U')">U</button>
          <button onclick="rotateFace('U', true)">U'</button>
          <button onclick="rotateFace('U', false, true)">U2</button>
        </div>
        <div class="button-row">
          <button onclick="rotateFace('D')">D</button>
          <button onclick="rotateFace('D', true)">D'</button>
          <button onclick="rotateFace('D', false, true)">D2</button>
        </div>
        <div class="button-row">
          <button onclick="rotateFace('R')">R</button>
          <button onclick="rotateFace('R', true)">R'</button>
          <button onclick="rotateFace('R', false, true)">R2</button>
        </div>
        <div class="button-row">
          <button onclick="rotateFace('L')">L</button>
          <button onclick="rotateFace('L', true)">L'</button>
          <button onclick="rotateFace('L', false, true)">L2</button>
        </div>
        <div class="button-row">
          <button onclick="rotateFace('F')">F</button>
          <button onclick="rotateFace('F', true)">F'</button>
          <button onclick="rotateFace('F', false, true)">F2</button>
        </div>
        <div class="button-row">
          <button onclick="rotateFace('B')">B</button>
          <button onclick="rotateFace('B', true)">B'</button>
          <button onclick="rotateFace('B', false, true)">B2</button>
        </div>
      </div>
      
      <div class="control-section">
        <h3>üìä Statistics</h3>
        <div style="font-size: 12px; line-height: 1.6;">
          <div>Total Moves: <span id="totalMoves">0</span></div>
          <div>Session Time: <span id="timer">00:00</span></div>
          <div>Cube State: <span id="cubeState">Solved</span></div>
        </div>
      </div>
    </div>
    
    <div id="gameArea">
      <div id="instructions">
        <strong>Controls:</strong><br>
        ‚Ä¢ Drag to rotate view<br>
        ‚Ä¢ Scroll to zoom<br>
        ‚Ä¢ Click cube faces to rotate<br>
        ‚Ä¢ Keys: U,D,L,R,F,B<br>
        ‚Ä¢ Hold Shift for prime moves<br>
        ‚Ä¢ Press 2 for double moves
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    class RubiksCube {
      constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.cubes = [];
        this.isAnimating = false;
        this.moveHistory = [];
        this.totalMoves = 0;
        this.startTime = Date.now();
        
        this.init();
        this.createCube();
        this.setupControls();
        this.setupEventListeners();
        this.animate();
        this.updateTimer();
      }
      
      init() {
        const gameArea = document.getElementById('gameArea');
        this.renderer.setSize(gameArea.clientWidth, gameArea.clientHeight);
        this.renderer.setClearColor(0x0b0e14);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        gameArea.appendChild(this.renderer.domElement);
        
        // Camera position
        this.camera.position.set(8, 8, 8);
        this.camera.lookAt(0, 0, 0);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        this.scene.add(directionalLight);
        
        const pointLight = new THREE.PointLight(0x2251f6, 0.3);
        pointLight.position.set(-5, 5, 5);
        this.scene.add(pointLight);
      }
      
      createCube() {
        const colors = {
          front: 0x00ff00,   // Green
          back: 0x0000ff,    // Blue  
          right: 0xff0000,   // Red
          left: 0xff8c00,    // Orange
          top: 0xffffff,     // White
          bottom: 0xffff00   // Yellow
        };
        
        const cubeSize = 0.95;
        const gap = 0.05;
        
        // Create 27 individual cubes (3x3x3)
        for (let x = -1; x <= 1; x++) {
          for (let y = -1; y <= 1; y++) {
            for (let z = -1; z <= 1; z++) {
              const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
              
              // Create materials for each face
              const materials = [
                new THREE.MeshLambertMaterial({ color: x === 1 ? colors.right : 0x333333 }),  // Right
                new THREE.MeshLambertMaterial({ color: x === -1 ? colors.left : 0x333333 }),  // Left
                new THREE.MeshLambertMaterial({ color: y === 1 ? colors.top : 0x333333 }),    // Top
                new THREE.MeshLambertMaterial({ color: y === -1 ? colors.bottom : 0x333333 }), // Bottom
                new THREE.MeshLambertMaterial({ color: z === 1 ? colors.front : 0x333333 }),  // Front
                new THREE.MeshLambertMaterial({ color: z === -1 ? colors.back : 0x333333 })   // Back
              ];
              
              const cube = new THREE.Mesh(geometry, materials);
              cube.position.set(x * (cubeSize + gap), y * (cubeSize + gap), z * (cubeSize + gap));
              cube.castShadow = true;
              cube.receiveShadow = true;
              
              // Store original position and grid coordinates
              cube.userData = {
                originalPosition: cube.position.clone(),
                gridX: x,
                gridY: y,
                gridZ: z
              };
              
              this.scene.add(cube);
              this.cubes.push(cube);
            }
          }
        }
      }
      
      setupControls() {
        this.mouse = { x: 0, y: 0 };
        this.isMouseDown = false;
        this.rotationX = 0;
        this.rotationY = 0;
        
        const canvas = this.renderer.domElement;
        
        canvas.addEventListener('mousedown', (e) => {
          this.isMouseDown = true;
          this.mouse.x = e.clientX;
          this.mouse.y = e.clientY;
        });
        
        canvas.addEventListener('mousemove', (e) => {
          if (!this.isMouseDown || this.isAnimating) return;
          
          const deltaX = e.clientX - this.mouse.x;
          const deltaY = e.clientY - this.mouse.y;
          
          this.rotationY += deltaX * 0.01;
          this.rotationX += deltaY * 0.01;
          
          // Limit rotation
          this.rotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotationX));
          
          this.updateCameraPosition();
          
          this.mouse.x = e.clientX;
          this.mouse.y = e.clientY;
        });
        
        canvas.addEventListener('mouseup', () => {
          this.isMouseDown = false;
        });
        
        canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          const distance = this.camera.position.length();
          const newDistance = Math.max(5, Math.min(15, distance + e.deltaY * 0.01));
          this.camera.position.setLength(newDistance);
        });
      }
      
      updateCameraPosition() {
        const distance = this.camera.position.length();
        this.camera.position.x = distance * Math.sin(this.rotationY) * Math.cos(this.rotationX);
        this.camera.position.y = distance * Math.sin(this.rotationX);
        this.camera.position.z = distance * Math.cos(this.rotationY) * Math.cos(this.rotationX);
        this.camera.lookAt(0, 0, 0);
      }
      
      rotateFace(face, isPrime = false, isDouble = false) {
        if (this.isAnimating) return;
        
        this.isAnimating = true;
        const rotationAngle = isPrime ? Math.PI/2 : -Math.PI/2;
        const iterations = isDouble ? 2 : 1;
        
        // Get cubes that belong to this face
        const faceCubes = this.getFaceCubes(face);
        
        this.animateRotation(faceCubes, face, rotationAngle, iterations, () => {
          this.isAnimating = false;
          this.recordMove(face, isPrime, isDouble);
          this.updateUI();
        });
      }
      
      getFaceCubes(face) {
        switch (face) {
          case 'U': return this.cubes.filter(cube => cube.userData.gridY === 1);
          case 'D': return this.cubes.filter(cube => cube.userData.gridY === -1);
          case 'R': return this.cubes.filter(cube => cube.userData.gridX === 1);
          case 'L': return this.cubes.filter(cube => cube.userData.gridX === -1);
          case 'F': return this.cubes.filter(cube => cube.userData.gridZ === 1);
          case 'B': return this.cubes.filter(cube => cube.userData.gridZ === -1);
          default: return [];
        }
      }
      
      animateRotation(cubes, face, angle, iterations, callback) {
        let currentIteration = 0;
        
        const performRotation = () => {
          const group = new THREE.Group();
          this.scene.add(group);
          
          // Add cubes to group
          cubes.forEach(cube => {
            this.scene.remove(cube);
            group.add(cube);
          });
          
          // Animate rotation
          const startRotation = group.rotation.clone();
          const targetRotation = startRotation.clone();
          
          switch (face) {
            case 'U': case 'D':
              targetRotation.y += angle;
              break;
            case 'R': case 'L':
              targetRotation.x += angle;
              break;
            case 'F': case 'B':
              targetRotation.z += angle;
              break;
          }
          
          let progress = 0;
          const duration = 300; // ms
          const startTime = Date.now();
          
          const animate = () => {
            const elapsed = Date.now() - startTime;
            progress = Math.min(elapsed / duration, 1);
            
            // Smooth easing
            const eased = 1 - Math.pow(1 - progress, 3);
            
            group.rotation.copy(startRotation);
            group.rotation.lerp(targetRotation, eased);
            
            if (progress < 1) {
              requestAnimationFrame(animate);
            } else {
              // Remove cubes from group and add back to scene
              while (group.children.length > 0) {
                const cube = group.children[0];
                group.remove(cube);
                this.scene.add(cube);
              }
              this.scene.remove(group);
              
              // Update cube grid positions
              this.updateCubePositions(cubes, face, angle > 0);
              
              currentIteration++;
              if (currentIteration < iterations) {
                setTimeout(performRotation, 50);
              } else {
                callback();
              }
            }
          };
          
          animate();
        };
        
        performRotation();
      }
      
      updateCubePositions(cubes, face, clockwise) {
        cubes.forEach(cube => {
          const { gridX, gridY, gridZ } = cube.userData;
          let newX = gridX, newY = gridY, newZ = gridZ;
          
          switch (face) {
            case 'U':
              if (clockwise) {
                newX = gridZ;
                newZ = -gridX;
              } else {
                newX = -gridZ;
                newZ = gridX;
              }
              break;
            case 'D':
              if (clockwise) {
                newX = -gridZ;
                newZ = gridX;
              } else {
                newX = gridZ;
                newZ = -gridX;
              }
              break;
            case 'R':
              if (clockwise) {
                newY = gridZ;
                newZ = -gridY;
              } else {
                newY = -gridZ;
                newZ = gridY;
              }
              break;
            case 'L':
              if (clockwise) {
                newY = -gridZ;
                newZ = gridY;
              } else {
                newY = gridZ;
                newZ = -gridY;
              }
              break;
            case 'F':
              if (clockwise) {
                newX = -gridY;
                newY = gridX;
              } else {
                newX = gridY;
                newY = -gridX;
              }
              break;
            case 'B':
              if (clockwise) {
                newX = gridY;
                newY = -gridX;
              } else {
                newX = -gridY;
                newY = gridX;
              }
              break;
          }
          
          cube.userData.gridX = newX;
          cube.userData.gridY = newY;
          cube.userData.gridZ = newZ;
          
          const cubeSize = 0.95;
          const gap = 0.05;
          cube.position.set(
            newX * (cubeSize + gap),
            newY * (cubeSize + gap),
            newZ * (cubeSize + gap)
          );
        });
      }
      
      recordMove(face, isPrime, isDouble) {
        let move = face;
        if (isDouble) move += '2';
        else if (isPrime) move += "'";
        
        this.moveHistory.push(move);
        this.totalMoves++;
      }
      
      scramble() {
        if (this.isAnimating) return;
        
        const moves = ['U', 'D', 'L', 'R', 'F', 'B'];
        const modifiers = ['', "'", '2'];
        
        let scrambleSequence = [];
        for (let i = 0; i < 20; i++) {
          const move = moves[Math.floor(Math.random() * moves.length)];
          const modifier = modifiers[Math.floor(Math.random() * modifiers.length)];
          scrambleSequence.push(move + modifier);
        }
        
        this.executeSequence(scrambleSequence);
      }
      
      executeSequence(sequence) {
        if (sequence.length === 0) return;
        
        const move = sequence.shift();
        const face = move[0];
        const isPrime = move.includes("'");
        const isDouble = move.includes('2');
        
        this.rotateFace(face, isPrime, isDouble);
        
        setTimeout(() => {
          this.executeSequence(sequence);
        }, 400);
      }
      
      solve() {
        if (this.isAnimating) return;
        
        const reverseSequence = this.moveHistory.slice().reverse().map(move => {
          if (move.includes('2')) return move;
          if (move.includes("'")) return move[0];
          return move[0] + "'";
        });
        
        this.moveHistory = [];
        this.executeSequence(reverseSequence);
      }
      
      reset() {
        if (this.isAnimating) return;
        
        this.moveHistory = [];
        this.totalMoves = 0;
        
        // Reset all cube positions and orientations
        this.cubes.forEach((cube, index) => {
          const x = Math.floor(index / 9) - 1;
          const y = Math.floor((index % 9) / 3) - 1;
          const z = (index % 3) - 1;
          
          cube.userData.gridX = x;
          cube.userData.gridY = y;
          cube.userData.gridZ = z;
          
          const cubeSize = 0.95;
          const gap = 0.05;
          cube.position.set(x * (cubeSize + gap), y * (cubeSize + gap), z * (cubeSize + gap));
          cube.rotation.set(0, 0, 0);
        });
        
        this.updateUI();
      }
      
      updateUI() {
        document.getElementById('moveCount').textContent = this.moveHistory.length;
        document.getElementById('totalMoves').textContent = this.totalMoves;
        document.getElementById('cubeState').textContent = this.moveHistory.length === 0 ? 'Solved' : 'Scrambled';
        document.getElementById('status').textContent = this.isAnimating ? 'Animating...' : 'Ready';
      }
      
      updateTimer() {
        const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
        const seconds = (elapsed % 60).toString().padStart(2, '0');
        document.getElementById('timer').textContent = `${minutes}:${seconds}`;
        
        setTimeout(() => this.updateTimer(), 1000);
      }
      
      setupEventListeners() {
        document.getElementById('scramble').addEventListener('click', () => this.scramble());
        document.getElementById('solve').addEventListener('click', () => this.solve());
        document.getElementById('reset').addEventListener('click', () => this.reset());
        
        document.addEventListener('keydown', (e) => {
          if (this.isAnimating) return;
          
          const key = e.key.toLowerCase();
          const isPrime = e.shiftKey;
          const isDouble = e.key === '2';
          
          switch (key) {
            case 'u': this.rotateFace('U', isPrime, isDouble); break;
            case 'd': this.rotateFace('D', isPrime, isDouble); break;
            case 'l': this.rotateFace('L', isPrime, isDouble); break;
            case 'r': this.rotateFace('R', isPrime, isDouble); break;
            case 'f': this.rotateFace('F', isPrime, isDouble); break;
            case 'b': this.rotateFace('B', isPrime, isDouble); break;
          }
        });
        
        window.addEventListener('resize', () => {
          const gameArea = document.getElementById('gameArea');
          this.camera.aspect = gameArea.clientWidth / gameArea.clientHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(gameArea.clientWidth, gameArea.clientHeight);
        });
      }
      
      animate() {
        requestAnimationFrame(() => this.animate());
        this.renderer.render(this.scene, this.camera);
      }
    }
    
    // Global function for button clicks
    let cubeInstance;
    
    function rotateFace(face, isPrime = false, isDouble = false) {
      if (cubeInstance) {
        cubeInstance.rotateFace(face, isPrime, isDouble);
      }
    }
    
    // Initialize when page loads
    window.addEventListener('load', () => {
      cubeInstance = new RubiksCube();
    });
  </script>
</body>
</html>