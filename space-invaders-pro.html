<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Invaders Pro - Retro Arcade Enhanced</title>
  <style>
    :root {
      --bg: #0a0a0f;
      --panel: #111827;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #22d3ee;
      --good: #34d399;
      --warn: #f59e0b;
      --bad: #ef4444;
      --neon-blue: #00ffff;
      --neon-green: #39ff14;
      --neon-purple: #bf00ff;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: 
        radial-gradient(circle at 20% 20%, rgba(34, 211, 238, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(191, 0, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 60%, rgba(57, 255, 20, 0.05) 0%, transparent 50%),
        linear-gradient(180deg, #0a0a0f 0%, #050508 100%);
      color: var(--text);
      font-family: 'Orbitron', system-ui, monospace;
      overflow: hidden;
      height: 100vh;
    }

    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 20px;
      position: relative;
    }

    .game-header {
      text-align: center;
      margin-bottom: 20px;
      z-index: 10;
    }

    .game-title {
      font-size: 3rem;
      font-weight: 900;
      background: linear-gradient(45deg, var(--neon-blue), var(--neon-purple), var(--neon-green));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(34, 211, 238, 0.5);
      margin-bottom: 10px;
      letter-spacing: 2px;
    }

    .game-subtitle {
      color: var(--muted);
      font-size: 1rem;
      letter-spacing: 1px;
    }

    .game-hud {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
      padding: 20px;
      background: rgba(17, 24, 39, 0.8);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(34, 211, 238, 0.3);
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(34, 211, 238, 0.2);
      min-width: 600px;
    }

    .hud-item {
      text-align: center;
      padding: 10px;
    }

    .hud-label {
      font-size: 0.8rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 5px;
    }

    .hud-value {
      font-size: 1.8rem;
      font-weight: 700;
      color: var(--neon-blue);
      text-shadow: 0 0 10px currentColor;
    }

    .game-canvas {
      border: 3px solid var(--neon-blue);
      border-radius: 10px;
      background: #000;
      box-shadow: 
        0 0 30px rgba(34, 211, 238, 0.4),
        inset 0 0 30px rgba(34, 211, 238, 0.1);
      display: block;
      position: relative;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-top: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .btn {
      padding: 12px 24px;
      background: linear-gradient(135deg, rgba(34, 211, 238, 0.2), rgba(34, 211, 238, 0.1));
      border: 2px solid var(--neon-blue);
      border-radius: 8px;
      color: var(--text);
      font-family: inherit;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      overflow: hidden;
    }

    .btn:hover {
      background: linear-gradient(135deg, rgba(34, 211, 238, 0.4), rgba(34, 211, 238, 0.2));
      box-shadow: 0 0 20px rgba(34, 211, 238, 0.5);
      transform: translateY(-2px);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn-danger {
      border-color: var(--bad);
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(239, 68, 68, 0.1));
    }

    .btn-danger:hover {
      background: linear-gradient(135deg, rgba(239, 68, 68, 0.4), rgba(239, 68, 68, 0.2));
      box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
    }

    .controls-hint {
      text-align: center;
      margin-top: 15px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .key {
      display: inline-block;
      padding: 3px 8px;
      background: rgba(34, 211, 238, 0.2);
      border: 1px solid var(--neon-blue);
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.8rem;
      margin: 0 2px;
      color: var(--neon-blue);
    }

    .game-over-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(10, 10, 15, 0.95);
      backdrop-filter: blur(15px);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
      z-index: 100;
    }

    .game-over-overlay.show {
      opacity: 1;
      pointer-events: all;
    }

    .game-over-title {
      font-size: 4rem;
      font-weight: 900;
      margin-bottom: 20px;
      text-shadow: 0 0 30px currentColor;
    }

    .game-over-title.win {
      color: var(--neon-green);
      background: linear-gradient(45deg, var(--neon-green), var(--neon-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .game-over-title.lose {
      color: var(--bad);
    }

    .final-score {
      font-size: 2rem;
      color: var(--neon-blue);
      margin-bottom: 30px;
    }

    .stars {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .star {
      position: absolute;
      width: 2px;
      height: 2px;
      background: white;
      border-radius: 50%;
      animation: twinkle 3s infinite;
    }

    @keyframes twinkle {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 1; }
    }

    .particle {
      position: absolute;
      pointer-events: none;
      z-index: 1000;
    }

    @keyframes explode {
      0% {
        opacity: 1;
        transform: scale(0) rotate(0deg);
      }
      100% {
        opacity: 0;
        transform: scale(2) rotate(360deg);
      }
    }

    .particle {
      animation: explode 0.6s ease-out forwards;
    }

    @media (max-width: 768px) {
      .game-title {
        font-size: 2rem;
      }
      
      .game-hud {
        min-width: auto;
        width: 100%;
      }
      
      .game-canvas {
        max-width: 100%;
        height: auto;
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
</head>
<body>
  <div class="stars" id="stars"></div>
  
  <div class="game-container">
    <div class="game-header">
      <h1 class="game-title">üëæ SPACE INVADERS PRO</h1>
      <p class="game-subtitle">RETRO ARCADE ENHANCED</p>
    </div>

    <div class="game-hud">
      <div class="hud-item">
        <div class="hud-label">Score</div>
        <div class="hud-value" id="score">0</div>
      </div>
      <div class="hud-item">
        <div class="hud-label">High Score</div>
        <div class="hud-value" id="highScore">0</div>
      </div>
      <div class="hud-item">
        <div class="hud-label">Lives</div>
        <div class="hud-value" id="lives">3</div>
      </div>
      <div class="hud-item">
        <div class="hud-label">Level</div>
        <div class="hud-value" id="level">1</div>
      </div>
      <div class="hud-item">
        <div class="hud-label">Status</div>
        <div class="hud-value" id="status">Ready</div>
      </div>
    </div>

    <canvas id="gameCanvas" class="game-canvas" width="800" height="600"></canvas>

    <div class="controls">
      <button id="startBtn" class="btn">üöÄ Start Game</button>
      <button id="pauseBtn" class="btn">‚è∏ Pause</button>
      <button id="resetBtn" class="btn btn-danger">üîÑ Reset</button>
    </div>

    <div class="controls-hint">
      <strong>Controls:</strong>
      <span class="key">‚Üê</span> <span class="key">‚Üí</span> Move
      <span class="key">Space</span> Fire
      <span class="key">P</span> Pause
      <span class="key">R</span> Reset
    </div>

    <div class="game-over-overlay" id="gameOverOverlay">
      <div class="game-over-title" id="gameOverTitle">GAME OVER</div>
      <div class="final-score" id="finalScore">Final Score: 0</div>
      <button id="playAgainBtn" class="btn">üéÆ Play Again</button>
    </div>
  </div>

  <script>
    class SpaceInvadersPro {
      constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Game state
        this.gameState = 'ready'; // ready, playing, paused, gameOver
        this.score = 0;
        this.highScore = parseInt(localStorage.getItem('spaceInvaders_highScore') || '0');
        this.lives = 3;
        this.level = 1;
        this.gameSpeed = 60; // FPS
        this.lastTime = 0;
        
        // Game objects
        this.player = null;
        this.bullets = [];
        this.enemies = [];
        this.enemyBullets = [];
        this.particles = [];
        this.stars = [];
        
        // Input handling
        this.keys = {};
        
        // Audio context for sound effects
        this.audioContext = null;
        
        this.initializeGame();
        this.setupEventListeners();
        this.createStarField();
        this.updateHUD();
        this.gameLoop();
      }

      initializeGame() {
        // Initialize player
        this.player = {
          x: this.canvas.width / 2 - 25,
          y: this.canvas.height - 60,
          width: 50,
          height: 30,
          speed: 6,
          alive: true
        };

        // Initialize enemies
        this.createEnemyFormation();
        
        // Initialize audio
        try {
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
          console.log('Audio not supported');
        }
      }

      createEnemyFormation() {
        this.enemies = [];
        const rows = 5;
        const cols = 10;
        const enemyWidth = 40;
        const enemyHeight = 30;
        const padding = 10;
        const startX = (this.canvas.width - (cols * (enemyWidth + padding))) / 2;
        const startY = 80;

        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            const enemyType = row < 2 ? 'fast' : row < 4 ? 'medium' : 'slow';
            this.enemies.push({
              x: startX + col * (enemyWidth + padding),
              y: startY + row * (enemyHeight + padding),
              width: enemyWidth,
              height: enemyHeight,
              type: enemyType,
              speed: 1 + (this.level * 0.2),
              direction: 1,
              alive: true,
              animationFrame: 0,
              lastShot: 0
            });
          }
        }
      }

      createStarField() {
        for (let i = 0; i < 100; i++) {
          this.stars.push({
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            speed: Math.random() * 2 + 0.5,
            brightness: Math.random()
          });
        }
      }

      setupEventListeners() {
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
          this.keys[e.code] = true;
          
          if (e.code === 'Space') {
            e.preventDefault();
            this.shoot();
          }
          if (e.key.toLowerCase() === 'p') {
            this.togglePause();
          }
          if (e.key.toLowerCase() === 'r') {
            this.resetGame();
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keys[e.code] = false;
        });

        // Button controls
        document.getElementById('startBtn').addEventListener('click', () => this.startGame());
        document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());
        document.getElementById('resetBtn').addEventListener('click', () => this.resetGame());
        document.getElementById('playAgainBtn').addEventListener('click', () => this.resetGame());
      }

      startGame() {
        if (this.gameState === 'ready' || this.gameState === 'gameOver') {
          this.gameState = 'playing';
          this.updateHUD();
        }
      }

      togglePause() {
        if (this.gameState === 'playing') {
          this.gameState = 'paused';
        } else if (this.gameState === 'paused') {
          this.gameState = 'playing';
        }
        this.updateHUD();
      }

      resetGame() {
        this.gameState = 'ready';
        this.score = 0;
        this.lives = 3;
        this.level = 1;
        this.bullets = [];
        this.enemyBullets = [];
        this.particles = [];
        
        this.player.x = this.canvas.width / 2 - 25;
        this.player.y = this.canvas.height - 60;
        this.player.alive = true;
        
        this.createEnemyFormation();
        this.updateHUD();
        document.getElementById('gameOverOverlay').classList.remove('show');
      }

      shoot() {
        if (this.gameState !== 'playing' || !this.player.alive) return;
        
        // Limit bullet rate
        const now = Date.now();
        if (now - (this.player.lastShot || 0) < 200) return;
        this.player.lastShot = now;

        this.bullets.push({
          x: this.player.x + this.player.width / 2,
          y: this.player.y,
          width: 4,
          height: 10,
          speed: 10,
          color: '#00ffff'
        });

        this.playSound(800, 0.1); // Shoot sound
      }

      playSound(frequency, duration) {
        if (!this.audioContext) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        oscillator.frequency.value = frequency;
        gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
        
        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + duration);
      }

      update(deltaTime) {
        if (this.gameState !== 'playing') return;

        // Update player
        if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
          this.player.x = Math.max(0, this.player.x - this.player.speed);
        }
        if (this.keys['ArrowRight'] || this.keys['KeyD']) {
          this.player.x = Math.min(this.canvas.width - this.player.width, this.player.x + this.player.speed);
        }

        // Update bullets
        this.bullets = this.bullets.filter(bullet => {
          bullet.y -= bullet.speed;
          return bullet.y > -bullet.height;
        });

        // Update enemy bullets
        this.enemyBullets = this.enemyBullets.filter(bullet => {
          bullet.y += bullet.speed;
          return bullet.y < this.canvas.height;
        });

        // Update enemies
        let changeDirection = false;
        let lowestEnemyY = 0;

        this.enemies.forEach(enemy => {
          if (!enemy.alive) return;
          
          enemy.animationFrame = (enemy.animationFrame + 0.1) % 2;
          enemy.x += enemy.speed * enemy.direction;
          
          if (enemy.x <= 0 || enemy.x >= this.canvas.width - enemy.width) {
            changeDirection = true;
          }
          
          lowestEnemyY = Math.max(lowestEnemyY, enemy.y);
          
          // Random enemy shooting
          if (Math.random() < 0.0005 * this.level && Date.now() - enemy.lastShot > 2000) {
            enemy.lastShot = Date.now();
            this.enemyBullets.push({
              x: enemy.x + enemy.width / 2,
              y: enemy.y + enemy.height,
              width: 3,
              height: 8,
              speed: 3 + Math.random() * 2,
              color: '#ff0040'
            });
          }
        });

        if (changeDirection) {
          this.enemies.forEach(enemy => {
            if (enemy.alive) {
              enemy.direction *= -1;
              enemy.y += 20;
            }
          });
        }

        // Check collisions
        this.checkCollisions();

        // Update particles
        this.particles = this.particles.filter(particle => {
          particle.life -= deltaTime;
          particle.x += particle.vx * deltaTime;
          particle.y += particle.vy * deltaTime;
          particle.vy += 0.1; // gravity
          return particle.life > 0;
        });

        // Update stars
        this.stars.forEach(star => {
          star.y += star.speed;
          if (star.y > this.canvas.height) {
            star.y = 0;
            star.x = Math.random() * this.canvas.width;
          }
        });

        // Check win/lose conditions
        const aliveEnemies = this.enemies.filter(e => e.alive);
        if (aliveEnemies.length === 0) {
          this.nextLevel();
        } else if (lowestEnemyY > this.player.y - 50) {
          this.playerHit();
        }
      }

      checkCollisions() {
        // Bullet vs enemies
        this.bullets.forEach((bullet, bulletIndex) => {
          this.enemies.forEach((enemy, enemyIndex) => {
            if (enemy.alive && this.isColliding(bullet, enemy)) {
              // Destroy bullet and enemy
              this.bullets.splice(bulletIndex, 1);
              enemy.alive = false;
              
              // Add score based on enemy type
              const points = enemy.type === 'fast' ? 30 : enemy.type === 'medium' ? 20 : 10;
              this.score += points;
              
              // Create explosion particles
              this.createExplosion(enemy.x + enemy.width/2, enemy.y + enemy.height/2, '#ff4000');
              
              this.playSound(300, 0.2); // Explosion sound
            }
          });
        });

        // Enemy bullets vs player
        this.enemyBullets.forEach((bullet, bulletIndex) => {
          if (this.player.alive && this.isColliding(bullet, this.player)) {
            this.enemyBullets.splice(bulletIndex, 1);
            this.playerHit();
          }
        });
      }

      playerHit() {
        this.lives--;
        this.createExplosion(this.player.x + this.player.width/2, this.player.y + this.player.height/2, '#00ffff');
        this.playSound(150, 0.5); // Player hit sound
        
        if (this.lives <= 0) {
          this.gameOver();
        } else {
          // Respawn player
          this.player.x = this.canvas.width / 2 - 25;
          this.player.alive = true;
        }
        this.updateHUD();
      }

      nextLevel() {
        this.level++;
        this.createEnemyFormation();
        this.playSound(600, 0.3); // Level up sound
        this.updateHUD();
      }

      gameOver() {
        this.gameState = 'gameOver';
        this.player.alive = false;
        
        if (this.score > this.highScore) {
          this.highScore = this.score;
          localStorage.setItem('spaceInvaders_highScore', this.highScore.toString());
        }
        
        document.getElementById('gameOverTitle').textContent = 'GAME OVER';
        document.getElementById('gameOverTitle').className = 'game-over-title lose';
        document.getElementById('finalScore').textContent = `Final Score: ${this.score}`;
        document.getElementById('gameOverOverlay').classList.add('show');
        
        this.updateHUD();
        this.playSound(100, 1); // Game over sound
      }

      createExplosion(x, y, color) {
        for (let i = 0; i < 10; i++) {
          this.particles.push({
            x: x,
            y: y,
            vx: (Math.random() - 0.5) * 200,
            vy: (Math.random() - 0.5) * 200,
            life: 500 + Math.random() * 300,
            maxLife: 500,
            color: color,
            size: Math.random() * 4 + 2
          });
        }
      }

      isColliding(rect1, rect2) {
        return rect1.x < rect2.x + rect2.width &&
               rect1.x + rect1.width > rect2.x &&
               rect1.y < rect2.y + rect2.height &&
               rect1.y + rect1.height > rect2.y;
      }

      updateHUD() {
        document.getElementById('score').textContent = this.score;
        document.getElementById('highScore').textContent = this.highScore;
        document.getElementById('lives').textContent = this.lives;
        document.getElementById('level').textContent = this.level;
        
        const statusMap = {
          'ready': 'Ready',
          'playing': 'Fighting',
          'paused': 'Paused',
          'gameOver': 'Game Over'
        };
        document.getElementById('status').textContent = statusMap[this.gameState];
      }

      draw() {
        // Clear canvas with gradient background
        const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
        gradient.addColorStop(0, '#0a0a0f');
        gradient.addColorStop(1, '#050508');
        this.ctx.fillStyle = gradient;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw stars
        this.ctx.fillStyle = '#ffffff';
        this.stars.forEach(star => {
          this.ctx.globalAlpha = star.brightness;
          this.ctx.fillRect(star.x, star.y, 2, 2);
        });
        this.ctx.globalAlpha = 1;

        // Draw player
        if (this.player.alive) {
          this.drawPlayer();
        }

        // Draw bullets
        this.bullets.forEach(bullet => this.drawBullet(bullet));
        this.enemyBullets.forEach(bullet => this.drawBullet(bullet));

        // Draw enemies
        this.enemies.forEach(enemy => {
          if (enemy.alive) this.drawEnemy(enemy);
        });

        // Draw particles
        this.particles.forEach(particle => this.drawParticle(particle));

        // Draw pause overlay
        if (this.gameState === 'paused') {
          this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
          
          this.ctx.fillStyle = '#00ffff';
          this.ctx.font = '48px Orbitron';
          this.ctx.textAlign = 'center';
          this.ctx.fillText('PAUSED', this.canvas.width / 2, this.canvas.height / 2);
        }
      }

      drawPlayer() {
        const { x, y, width, height } = this.player;
        
        // Player body (triangle shape)
        this.ctx.fillStyle = '#00ffff';
        this.ctx.beginPath();
        this.ctx.moveTo(x + width/2, y);
        this.ctx.lineTo(x, y + height);
        this.ctx.lineTo(x + width, y + height);
        this.ctx.closePath();
        this.ctx.fill();
        
        // Glow effect
        this.ctx.shadowColor = '#00ffff';
        this.ctx.shadowBlur = 10;
        this.ctx.fill();
        this.ctx.shadowBlur = 0;
      }

      drawEnemy(enemy) {
        const { x, y, width, height, type, animationFrame } = enemy;
        
        // Color based on enemy type
        const colors = {
          'fast': '#ff0040',
          'medium': '#ff8000',
          'slow': '#00ff40'
        };
        
        this.ctx.fillStyle = colors[type];
        
        // Animated enemy shape
        const offset = Math.floor(animationFrame) * 2;
        this.ctx.fillRect(x + offset, y + 5, width - offset*2, height - 10);
        this.ctx.fillRect(x + 5, y, width - 10, 5);
        this.ctx.fillRect(x + 5, y + height - 5, width - 10, 5);
        
        // Eyes
        this.ctx.fillStyle = '#ffffff';
        this.ctx.fillRect(x + 10, y + 8, 4, 4);
        this.ctx.fillRect(x + width - 14, y + 8, 4, 4);
      }

      drawBullet(bullet) {
        this.ctx.fillStyle = bullet.color;
        this.ctx.shadowColor = bullet.color;
        this.ctx.shadowBlur = 5;
        this.ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
        this.ctx.shadowBlur = 0;
      }

      drawParticle(particle) {
        const alpha = particle.life / particle.maxLife;
        this.ctx.fillStyle = particle.color;
        this.ctx.globalAlpha = alpha;
        this.ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
        this.ctx.globalAlpha = 1;
      }

      gameLoop(currentTime = 0) {
        const deltaTime = currentTime - this.lastTime;
        this.lastTime = currentTime;

        this.update(deltaTime);
        this.draw();

        requestAnimationFrame((time) => this.gameLoop(time));
      }
    }

    // Initialize game when page loads
    window.addEventListener('load', () => {
      // Create animated stars in background
      const starsContainer = document.getElementById('stars');
      for (let i = 0; i < 50; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.animationDelay = Math.random() * 3 + 's';
        starsContainer.appendChild(star);
      }
      
      new SpaceInvadersPro();
    });
  </script>
</body>
</html>
